{
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "Click Fun",
        "alternateName": "Click Fun",
        "description": "Click Fun æ˜¯ä¸€æ¬¾å…è²»çš„ç·šä¸Šé»æ“ŠéŠæˆ²ï¼Œæ”¯æ´ PWA é›¢ç·šéŠæˆ²ã€TPS è¨ˆç®—åŠŸèƒ½ã€‚ç²‰è‰²Ã—å¤©è—é…è‰²ä¸»é¡Œï¼Œæ”¯æ´æ‰‹æ©Ÿã€å¹³æ¿ã€é›»è…¦å¤šå¹³å°ä½¿ç”¨ã€‚",
        "url": "https://haotool.github.io/clickfun/",
        "applicationCategory": "Game",
        "applicationSubCategory": "CasualGame",
        "operatingSystem": "Any",
        "browserRequirements": "Requires JavaScript. HTML5 compatible browser.",
        "softwareVersion": "7.2.0",
        "dateCreated": "2024-01-01",
        "dateModified": "2025-08-16",
        "datePublished": "2024-01-01",
        "inLanguage": "zh-TW",
        "isAccessibleForFree": true,
        "author": {
          "@type": "Person",
          "name": "s123104",
          "identifier": "s123104"
        },
        "publisher": {
          "@type": "Person",
          "name": "s123104"
        },
        "offers": {
          "@type": "Offer",
          "price": "0",
          "priceCurrency": "TWD",
          "availability": "https://schema.org/InStock",
          "category": "Free"
        },
        "screenshot": "https://haotool.github.io/clickfun/icons/click-fun.png",
        "image": "https://haotool.github.io/clickfun/icons/click-fun.png",
        "thumbnailUrl": "https://haotool.github.io/clickfun/icons/icon-192x192.png",
        "featureList": [
          "TPS (æ¯ç§’é»æ“Šæ¬¡æ•¸) è¨ˆç®—",
          "PWA é›¢ç·šéŠæˆ²æ”¯æ´",
          "å¤šå¹³å°ç›¸å®¹ (æ‰‹æ©Ÿã€å¹³æ¿ã€é›»è…¦)",
          "ç²‰è‰²Ã—å¤©è—æ¼¸å±¤é…è‰²ä¸»é¡Œ",
          "å³æ™‚çµ±è¨ˆèˆ‡è¨˜éŒ„",
          "ç„¡éœ€è¨»å†Šæˆ–ç™»å…¥",
          "æ”¯æ´è§¸æ§å’Œæ»‘é¼ æ“ä½œ",
          "Service Worker å¿«å–æ©Ÿåˆ¶"
        ],
        "requirements": "JavaScript enabled browser, HTML5 support",
        "gamePlatform": ["Web Browser", "Mobile", "Desktop", "Progressive Web App"],
        "genre": ["Casual", "Arcade", "Clicker"],
        "playMode": "SinglePlayer",
        "accessibilityFeature": [
          "keyboard navigation",
          "touch support",
          "screen reader compatible"
        ],
        "keywords": "é»æ“ŠéŠæˆ², Click Fun, Click Fun, å…è²»éŠæˆ², PWAéŠæˆ², ç·šä¸ŠéŠæˆ², TPSè¨ˆç®—, é»æ“Šé€Ÿåº¦, æ‰‹æ©ŸéŠæˆ², é›¢ç·šéŠæˆ²",
        "mainEntity": {
          "@type": "Game",
          "name": "Click Fun",
          "description": "æ¸¬è©¦ä½ çš„é»æ“Šé€Ÿåº¦ï¼è¨ˆç®—æ¯ç§’é»æ“Šæ¬¡æ•¸ (TPS)ï¼ŒæŒ‘æˆ°ä½ çš„æ¥µé™ã€‚",
          "genre": "Casual Gaming",
          "playMode": "SinglePlayer",
          "gameItem": {
            "@type": "Thing",
            "name": "é»æ“ŠæŒ‰éˆ•",
            "description": "ä¸»è¦éŠæˆ²äº’å‹•å…ƒç´ "
          }
        },
        "potentialAction": {
          "@type": "PlayAction",
          "target": "https://haotool.github.io/clickfun/",
          "name": "é–‹å§‹éŠæˆ²"
        }
      }
{
        "@context": "https://schema.org",
        "@type": "FAQPage",
        "mainEntity": [
          {
            "@type": "Question",
            "name": "Click Fun æ˜¯ä»€éº¼ï¼Ÿ",
            "acceptedAnswer": {
              "@type": "Answer",
              "text": "Click Fun æ˜¯ä¸€æ¬¾å…è²»çš„ç·šä¸Šé»æ“ŠéŠæˆ²ï¼Œæ¡ç”¨ PWA æŠ€è¡“æ”¯æ´é›¢ç·šéŠæˆ²é«”é©—ã€‚æä¾›ç²¾ç¢ºçš„ TPS (æ¯ç§’é»æ“Šæ¬¡æ•¸) è¨ˆç®—ç³»çµ±ï¼Œè®“æ‚¨æ¸¬è©¦å’Œæå‡é»æ“Šé€Ÿåº¦ã€‚"
            }
          },
          {
            "@type": "Question",
            "name": "å¦‚ä½•é–‹å§‹éŠæˆ²ï¼Ÿ",
            "acceptedAnswer": {
              "@type": "Answer",
              "text": "é–‹å•Ÿç€è¦½å™¨è¨ªå• Click Fun ç¶²ç«™ï¼Œé»æ“Šã€Œå–®äººæŒ‘æˆ°æ¨¡å¼ã€æˆ–ã€Œé›™äººå°æˆ°æ¨¡å¼ã€å³å¯ç«‹å³é–‹å§‹éŠæˆ²ï¼Œç„¡éœ€ä¸‹è¼‰å®‰è£ä»»ä½•è»Ÿé«”ã€‚"
            }
          },
          {
            "@type": "Question",
            "name": "ä»€éº¼æ˜¯ TPS è¨ˆç®—ï¼Ÿ",
            "acceptedAnswer": {
              "@type": "Answer",
              "text": "TPS æ˜¯ Taps Per Second (æ¯ç§’é»æ“Šæ¬¡æ•¸) çš„ç¸®å¯«ï¼ŒClick Fun æä¾›ç²¾ç¢ºçš„ TPS è¨ˆç®—ç³»çµ±ï¼Œå³æ™‚é¡¯ç¤ºæ‚¨çš„é»æ“Šé€Ÿåº¦è¡¨ç¾ï¼Œå¹«åŠ©æ‚¨æŒ‘æˆ°æ¥µé™ã€‚"
            }
          },
          {
            "@type": "Question",
            "name": "æ”¯æ´å“ªäº›è£ç½®ï¼Ÿ",
            "acceptedAnswer": {
              "@type": "Answer",
              "text": "Click Fun å®Œç¾æ”¯æ´æ‰‹æ©Ÿã€å¹³æ¿ã€é›»è…¦ç­‰å¤šç¨®è£ç½®ï¼Œæ¡ç”¨éŸ¿æ‡‰å¼è¨­è¨ˆç¢ºä¿åœ¨ä»»ä½•è¢å¹•å°ºå¯¸ä¸‹éƒ½èƒ½æä¾›æœ€ä½³éŠæˆ²é«”é©—ã€‚"
            }
          },
          {
            "@type": "Question",
            "name": "ä»€éº¼æ˜¯ PWA é›¢ç·šåŠŸèƒ½ï¼Ÿ",
            "acceptedAnswer": {
              "@type": "Answer",
              "text": "PWA (Progressive Web App) æŠ€è¡“è®“ Click Fun æ”¯æ´é›¢ç·šéŠæˆ²ï¼Œå³ä½¿æ²’æœ‰ç¶²è·¯é€£ç·šä¹Ÿèƒ½ç¹¼çºŒéŠæˆ²ï¼Œä¸¦å¯å®‰è£åˆ°è£ç½®ä¸»ç•«é¢åƒåŸç”Ÿ App ä¸€æ¨£ä½¿ç”¨ã€‚"
            }
          },
          {
            "@type": "Question",
            "name": "éŠæˆ²å®Œå…¨å…è²»å—ï¼Ÿ",
            "acceptedAnswer": {
              "@type": "Answer",
              "text": "æ˜¯çš„ï¼ŒClick Fun å®Œå…¨å…è²»ï¼Œç„¡éœ€è¨»å†Šæˆ–ç™»å…¥ï¼Œç„¡éš±è—è²»ç”¨ï¼Œä¹Ÿæ²’æœ‰å»£å‘Šå¹²æ“¾ï¼Œè®“æ‚¨å°ˆæ³¨äº«å—ç´”ç²¹çš„é»æ“Šæ¨‚è¶£ã€‚"
            }
          },
          {
            "@type": "Question",
            "name": "å¦‚ä½•æå‡é»æ“Šé€Ÿåº¦ï¼Ÿ",
            "acceptedAnswer": {
              "@type": "Answer",
              "text": "å»ºè­°ä½¿ç”¨é£ŸæŒ‡å¿«é€Ÿé»æ“Šï¼Œä¿æŒæ‰‹éƒ¨æ”¾é¬†ï¼Œæ‰¾åˆ°ç¯€å¥æ„Ÿã€‚ç·´ç¿’æ™‚å¯å¾çŸ­æ™‚é–“é–‹å§‹ï¼Œé€æ¼¸å¢åŠ æŒçºŒæ™‚é–“ï¼Œå®šæœŸæŸ¥çœ‹ TPS çµ±è¨ˆä¾†è¿½è¹¤é€²æ­¥ã€‚"
            }
          },
          {
            "@type": "Question",
            "name": "é›™äººå°æˆ°å¦‚ä½•é€²è¡Œï¼Ÿ",
            "acceptedAnswer": {
              "@type": "Answer",
              "text": "é¸æ“‡é›™äººå°æˆ°æ¨¡å¼ï¼Œå…©ä½ç©å®¶å¯åœ¨åŒä¸€è¢å¹•ä¸Šç«¶è³½ï¼Œå·¦å³åˆ†å±è¨­è¨ˆï¼Œå³æ™‚é¡¯ç¤ºé›™æ–¹é»æ“Šæ•¸å’Œ TPSï¼Œå¢åŠ ç«¶çˆ­æ¨‚è¶£å’Œäº’å‹•æ€§ã€‚"
            }
          },
          {
            "@type": "Question",
            "name": "æœ‰æ’è¡Œæ¦œåŠŸèƒ½å—ï¼Ÿ",
            "acceptedAnswer": {
              "@type": "Answer",
              "text": "æœ‰çš„ï¼ŒClick Fun æä¾›æœ¬åœ°æ’è¡Œæ¦œåŠŸèƒ½ï¼Œè¨˜éŒ„æ‚¨çš„æœ€ä½³æˆç¸¾ï¼Œæ”¯æ´å–®äººæ¨¡å¼å’Œé›™äººå°æˆ°æ¨¡å¼çš„åˆ†åˆ¥æ’åï¼Œæ¿€å‹µæ‚¨ä¸æ–·æŒ‘æˆ°æ›´é«˜åˆ†æ•¸ã€‚"
            }
          },
          {
            "@type": "Question",
            "name": "è³‡æ–™æœƒè¢«ä¿å­˜å—ï¼Ÿ",
            "acceptedAnswer": {
              "@type": "Answer",
              "text": "æ‰€æœ‰éŠæˆ²è¨˜éŒ„å’Œè¨­å®šéƒ½ä¿å­˜åœ¨æ‚¨çš„è£ç½®æœ¬åœ°ï¼Œç¢ºä¿éš±ç§å®‰å…¨ã€‚å³ä½¿é›¢ç·šä¹Ÿèƒ½æŸ¥çœ‹æ­·å²æˆç¸¾ï¼ŒPWA æŠ€è¡“ç¢ºä¿è³‡æ–™ä¸æœƒéºå¤±ã€‚"
            }
          }
        ]
      }
{
        "@context": "https://schema.org",
        "@type": "VideoGame",
        "name": "Click Fun - é»æ“Šæ¨‚è¶£éŠæˆ²",
        "alternateName": ["Click Fun", "Click Fun", "é»æ“ŠéŠæˆ²"],
        "description": "å…è²»çš„ç·šä¸Šé»æ“Šé€Ÿåº¦æ¸¬è©¦éŠæˆ²ï¼Œæ”¯æ´ PWA æŠ€è¡“å¯é›¢ç·šéŠæˆ²ã€‚æ¸¬è©¦æ‚¨çš„é»æ“Šé€Ÿåº¦ï¼Œè¨ˆç®— TPS (æ¯ç§’é»æ“Šæ¬¡æ•¸)ï¼Œäº«å—ç²‰è‰²Ã—å¤©è—çš„ç¾éº—é…è‰²ã€‚",
        "url": "https://haotool.github.io/clickfun/",
        "image": "https://haotool.github.io/clickfun/icons/click-fun.png",
        "genre": ["Casual", "Arcade", "Clicker Game"],
        "playMode": "SinglePlayer",
        "applicationCategory": "Game",
        "gamePlatform": ["PC", "Mobile", "Web Browser", "PWA"],
        "operatingSystem": "Cross-platform",
        "processorRequirements": "Any modern processor",
        "memoryRequirements": "Minimal RAM required",
        "storageRequirements": "< 1MB (PWA cache)",
        "datePublished": "2024-01-01",
        "dateModified": "2025-08-16",
        "version": "7.2.0",
        "inLanguage": "zh-TW",
        "isAccessibleForFree": true,
        "author": {
          "@type": "Person",
          "name": "s123104"
        },
        "publisher": {
          "@type": "Person",
          "name": "s123104"
        },
        "offers": {
          "@type": "Offer",
          "price": "0",
          "priceCurrency": "TWD",
          "availability": "https://schema.org/InStock"
        },
        "aggregateRating": {
          "@type": "AggregateRating",
          "ratingValue": "4.8",
          "ratingCount": "1",
          "bestRating": "5",
          "worstRating": "1"
        },
        "contentRating": "Everyone",
        "keywords": "é»æ“ŠéŠæˆ², é€Ÿåº¦æ¸¬è©¦, TPSè¨ˆç®—, PWAéŠæˆ², å…è²»éŠæˆ²",
        "mainEntityOfPage": "https://haotool.github.io/clickfun/"
      }
{
        "@context": "https://schema.org",
        "@type": "HowTo",
        "name": "å¦‚ä½•ç© ClickFun é»æ“ŠéŠæˆ²",
        "description": "å­¸ç¿’å¦‚ä½•ä½¿ç”¨ ClickFun é€²è¡Œé»æ“Šé€Ÿåº¦æ¸¬è©¦å’Œæå‡ TPS è¡¨ç¾çš„å®Œæ•´æŒ‡å—",
        "totalTime": "PT2M",
        "estimatedCost": {
          "@type": "MonetaryAmount",
          "currency": "TWD",
          "value": "0"
        },
        "supply": [
          {
            "@type": "HowToSupply",
            "name": "ä»»ä½•æ”¯æ´ç€è¦½å™¨çš„è£ç½®"
          }
        ],
        "tool": [
          {
            "@type": "HowToTool",
            "name": "æ»‘é¼ ã€è§¸æ§è¢å¹•æˆ–éµç›¤"
          }
        ],
        "step": [
          {
            "@type": "HowToStep",
            "name": "é–‹å§‹éŠæˆ²",
            "text": "é–‹å•Ÿç€è¦½å™¨è¨ªå• ClickFun ç¶²ç«™ï¼Œé¸æ“‡å–®äººæŒ‘æˆ°æ¨¡å¼æˆ–é›™äººå°æˆ°æ¨¡å¼é–‹å§‹éŠæˆ²",
            "url": "https://haotool.github.io/clickfun/#start",
            "image": "https://haotool.github.io/clickfun/icons/click-fun.png"
          },
          {
            "@type": "HowToStep",
            "name": "é€²è¡Œé»æ“Šæ¸¬è©¦",
            "text": "å¿«é€Ÿé»æ“ŠéŠæˆ²å€åŸŸï¼Œç³»çµ±æœƒå³æ™‚è¨ˆç®—ä¸¦é¡¯ç¤ºæ‚¨çš„ TPS (æ¯ç§’é»æ“Šæ¬¡æ•¸) è¡¨ç¾",
            "url": "https://haotool.github.io/clickfun/#gameplay"
          },
          {
            "@type": "HowToStep",
            "name": "æŸ¥çœ‹æˆç¸¾",
            "text": "éŠæˆ²çµæŸå¾ŒæŸ¥çœ‹è©³ç´°çµ±è¨ˆæ•¸æ“šï¼ŒåŒ…æ‹¬ç¸½é»æ“Šæ•¸ã€å¹³å‡ TPS å’Œæœ€é«˜ TPS è¨˜éŒ„",
            "url": "https://haotool.github.io/clickfun/#results"
          },
          {
            "@type": "HowToStep",
            "name": "æå‡æŠ€å·§",
            "text": "ä½¿ç”¨é£ŸæŒ‡å¿«é€Ÿé»æ“Šï¼Œä¿æŒæ‰‹éƒ¨æ”¾é¬†ï¼Œæ‰¾åˆ°ç¯€å¥æ„Ÿã€‚å®šæœŸç·´ç¿’ä»¥æå‡é»æ“Šé€Ÿåº¦",
            "url": "https://haotool.github.io/clickfun/#tips"
          }
        ]
      }
(function () {
        const noop = () => {};
        ['log', 'warn', 'error', 'info', 'debug', 'time', 'timeEnd'].forEach(m => {
          try {
            console[m] = noop;
          } catch (e) {}
        });
      })();

      // ===== ç‰ˆæœ¬ç®¡ç† =====
      const APP_VERSION = '7.1.4';
      const SW_ENHANCED_VERSION = 'clickfun-enhanced-v1.1.0';

      // æ›´æ–°ç‰ˆæœ¬è™Ÿé¡¯ç¤º
      function updateVersionDisplay() {
        const versionDisplay = document.getElementById('versionDisplay');
        if (versionDisplay) {
          versionDisplay.textContent = `v${APP_VERSION}`;
        }
      }

      // ç•¶å‰ç‰ˆæœ¬çš„æ‰€æœ‰å¿«å–åç¨±æ¨¡å¼
      const CURRENT_CACHE_PATTERNS = [
        `clickfun-v${APP_VERSION}`,
        `${SW_ENHANCED_VERSION}-app-shell`,
        `${SW_ENHANCED_VERSION}-static`,
        `${SW_ENHANCED_VERSION}-dynamic`,
        `${SW_ENHANCED_VERSION}-images`,
      ];

      // ===== é¼“å‹µæ–‡å­—ç³»çµ± =====
      const ENCOURAGEMENT_MESSAGES = [
        // 1-5 TPS: æ–°æ‰‹é¼“å‹µ
        { minTPS: 1, maxTPS: 2, message: 'ä¸éŒ¯çš„é–‹å§‹ï¼æ‰‹æŒ‡æ­£åœ¨ç†±èº«ä¸­ ğŸ”¥' },
        { minTPS: 2, maxTPS: 3, message: 'æ„Ÿè¦ºåˆ°ç¯€å¥äº†å—ï¼Ÿç¹¼çºŒä¿æŒï¼ ğŸµ' },
        { minTPS: 3, maxTPS: 4, message: 'ä½ çš„æ‰‹æŒ‡é–‹å§‹è·³èˆäº†ï¼ğŸ’ƒ' },
        { minTPS: 4, maxTPS: 5, message: 'ç©©å®šçš„ç¯€å¥ï¼Œå°±åƒå¿ƒè·³ä¸€æ¨£ï¼â¤ï¸' },
        { minTPS: 5, maxTPS: 6, message: 'æ‰‹æŒ‡éˆæ´»åº¦ +1ï¼ç¹¼çºŒåŠ æ²¹ï¼âœ¨' },

        // 6-15 TPS: é€²éšé¼“å‹µ
        { minTPS: 6, maxTPS: 8, message: 'å“‡ï¼ä½ çš„æ‰‹æŒ‡æœ‰é­”æ³•å—ï¼ŸğŸª„' },
        { minTPS: 8, maxTPS: 10, message: 'é€™é€Ÿåº¦è®“è¢å¹•éƒ½é–‹å§‹ç™¼ç‡™äº†ï¼ğŸ”¥' },
        { minTPS: 10, maxTPS: 12, message: 'æ‰‹æŒ‡è®Šæˆé–ƒé›»äº†ï¼âš¡' },
        { minTPS: 12, maxTPS: 15, message: 'ä½ æ˜¯é»æ“Šç•Œçš„é‹¼ç´å®¶ï¼ğŸ¹' },
        { minTPS: 15, maxTPS: 18, message: 'æ‰‹é€Ÿå¿«åˆ°æ¨¡ç³Šäº†ï¼ğŸ‘»' },

        // 16-30 TPS: é«˜æ‰‹ç´šé¼“å‹µ
        { minTPS: 18, maxTPS: 20, message: 'é€™æ˜¯äººé¡çš„æ¥µé™å—ï¼Ÿï¼ğŸš€' },
        { minTPS: 20, maxTPS: 22, message: 'æ‰‹æŒ‡å·²ç¶“çªç ´éŸ³é€Ÿï¼ğŸ’¨' },
        { minTPS: 22, maxTPS: 25, message: 'ä½ çš„æ‰‹æŒ‡æ˜¯æ¸¦è¼ªå¢å£“çš„å—ï¼ŸğŸï¸' },
        { minTPS: 25, maxTPS: 28, message: 'é€£èœ‚é³¥éƒ½è‡ªå˜†ä¸å¦‚ï¼ğŸ¦' },
        { minTPS: 28, maxTPS: 30, message: 'æ‰‹æŒ‡è®Šæˆå…‰é€Ÿäº†ï¼ğŸ’«' },

        // 31-50 TPS: è¶…äººç´šé¼“å‹µ
        { minTPS: 30, maxTPS: 35, message: 'ä½ ç¢ºå®šä¸æ˜¯æ©Ÿå™¨äººå—ï¼ŸğŸ¤–' },
        { minTPS: 35, maxTPS: 40, message: 'æ‰‹æŒ‡å·²ç¶“é€²å…¥è¶…æ¬¡å…ƒç©ºé–“ï¼ğŸŒŒ' },
        { minTPS: 40, maxTPS: 45, message: 'é€™é€Ÿåº¦é€£é–ƒé›»éƒ½è¿½ä¸ä¸Šï¼âš¡âš¡' },
        { minTPS: 45, maxTPS: 50, message: 'ä½ çš„æ‰‹æŒ‡é•åäº†ç‰©ç†å®šå¾‹ï¼ğŸ§ª' },
        { minTPS: 50, maxTPS: 55, message: 'æ‰‹æŒ‡å·²ç¶“è¶…è¶Šæ™‚ç©ºé™åˆ¶ï¼â°' },

        // 51-70 TPS: ç¥ç´šé¼“å‹µ
        { minTPS: 55, maxTPS: 60, message: 'é€™æ˜¯å‚³èªªä¸­çš„ç¥ä¹‹æ‰‹é€Ÿï¼ğŸ‘‘' },
        { minTPS: 60, maxTPS: 65, message: 'ä½ çš„æ‰‹æŒ‡æ“æœ‰é‡å­ç³¾çºèƒ½åŠ›ï¼âš›ï¸' },
        { minTPS: 65, maxTPS: 70, message: 'æ‰‹æŒ‡å·²ç¶“é”åˆ°å®‡å®™ç´šé »ç‡ï¼ğŸŒŸ' },
        { minTPS: 70, maxTPS: 75, message: 'é€£æ™‚é–“éƒ½ç‚ºä½ çš„é€Ÿåº¦åœæ­¢ï¼â¸ï¸' },
        { minTPS: 75, maxTPS: 80, message: 'ä½ çš„æ‰‹æŒ‡å‰µé€ äº†æ–°çš„ç¶­åº¦ï¼ğŸ”®' },

        // 81-100 TPS: çµ‚æ¥µé¼“å‹µ
        { minTPS: 80, maxTPS: 85, message: 'æ‰‹æŒ‡å·²ç¶“æˆç‚ºç´”èƒ½é‡é«”ï¼ğŸ’¥' },
        { minTPS: 85, maxTPS: 90, message: 'ä½ é‡æ–°å®šç¾©äº†ã€Œå¿«ã€é€™å€‹å­—ï¼ğŸ“š' },
        { minTPS: 90, maxTPS: 95, message: 'æ‰‹æŒ‡é€Ÿåº¦å·²ç¶“ç„¡æ³•ç”¨ç§‘å­¸è§£é‡‹ï¼ğŸ”¬' },
        { minTPS: 95, maxTPS: 100, message: 'ä½ å°±æ˜¯é»æ“Šå®‡å®™çš„å‰µé€ è€…ï¼ğŸŒ' },
        { minTPS: 100, maxTPS: Infinity, message: 'å‚³èªªä¸­çš„é»æ“Šä¹‹ç¥é™è‡¨ï¼ğŸ‘¼' },
      ];

      // ç²å–å°æ‡‰ TPS çš„é¼“å‹µæ–‡å­—
      function getEncouragementMessage(tps) {
        for (const msg of ENCOURAGEMENT_MESSAGES) {
          if (tps >= msg.minTPS && tps < msg.maxTPS) {
            return msg.message;
          }
        }
        return ENCOURAGEMENT_MESSAGES[ENCOURAGEMENT_MESSAGES.length - 1].message;
      }

      // ç‰ˆæœ¬æª¢æ¸¬å’Œè‡ªå‹•æ›´æ–°
      async function checkForUpdates() {
        if ('serviceWorker' in navigator) {
          try {
            const registration = await navigator.serviceWorker.ready;
            if (registration.active) {
              // æª¢æŸ¥æœ¬åœ°å­˜å„²çš„ç‰ˆæœ¬
              const storedVersion = localStorage.getItem('app_version');
              if (storedVersion && storedVersion !== APP_VERSION) {
                console.log(`ç‰ˆæœ¬æ›´æ–°ï¼š${storedVersion} â†’ ${APP_VERSION}`);

                // é¡¯ç¤ºç‰ˆæœ¬æ›´æ–°æç¤º
                showVersionUpdateToast(storedVersion, APP_VERSION);

                // æ¸…é™¤èˆŠç‰ˆæœ¬å¿«å–
                if ('caches' in window) {
                  const cacheNames = await caches.keys();
                  await Promise.all(
                    cacheNames.map(cacheName => {
                      // æª¢æŸ¥æ˜¯å¦ç‚ºç•¶å‰ç‰ˆæœ¬çš„å¿«å–
                      const isCurrentVersion = CURRENT_CACHE_PATTERNS.includes(cacheName);

                      if (!isCurrentVersion) {
                        console.log(`æ¸…é™¤èˆŠå¿«å–: ${cacheName}`);
                        return caches.delete(cacheName);
                      } else {
                        console.log(`ä¿ç•™ç•¶å‰å¿«å–: ${cacheName}`);
                      }
                    })
                  );
                }
                // æ›´æ–°ç‰ˆæœ¬è™Ÿ
                localStorage.setItem('app_version', APP_VERSION);

                // å»¶é²é‡æ–°è¼‰å…¥ï¼Œè®“ç”¨æˆ¶çœ‹åˆ°æ›´æ–°æç¤º
                setTimeout(() => {
                  window.location.reload();
                }, 3000);
                return;
              }
              // é¦–æ¬¡å®‰è£æˆ–ç‰ˆæœ¬ç›¸åŒ
              localStorage.setItem('app_version', APP_VERSION);
            }
          } catch (error) {
            console.log('ç‰ˆæœ¬æª¢æ¸¬å¤±æ•—:', error);
          }
        }
      }

      // é¡¯ç¤ºç‰ˆæœ¬æ›´æ–°æç¤º
      function showVersionUpdateToast(oldVersion, newVersion) {
        const toast = document.createElement('div');
        toast.className = 'version-update-toast';
        toast.innerHTML = `
          <div class="toast-content">
            <div class="toast-icon">
              <span class="material-symbols-rounded" style="color: #ffd700;">celebration</span>
            </div>
            <div class="toast-text">
              <div class="toast-title">ç‰ˆæœ¬æ›´æ–°æª¢æ¸¬åˆ°ï¼</div>
              <div class="toast-subtitle">å¾ v${oldVersion} æ›´æ–°è‡³ v${newVersion}</div>
            </div>
            <button class="toast-close" onclick="this.parentElement.parentElement.remove()">Ã—</button>
          </div>
        `;

        document.body.appendChild(toast);

        // 3ç§’å¾Œè‡ªå‹•æ¶ˆå¤±
        setTimeout(() => {
          if (toast.parentElement) {
            toast.remove();
          }
        }, 3000);
      }

      // ===== éŠæˆ²ç‹€æ…‹ =====
      const GameState = {
        isPlaying: false,
        hasStarted: false, // æ˜¯å¦å·²ç¶“é–‹å§‹è¨ˆæ™‚
        mode: 'single',
        timeLeft: 30,
        scores: { single: 0, player1: 0, player2: 0 },
        settings: {
          soundEnabled: true,
          vibrationEnabled: true,
          gameDuration: 30,
          rippleEnabled: true,
          lightningEnabled: true,
          showTps: true,
        },
        pointers: new Map(),
        activePointers: new Map(),
        lastTapTime: { single: 0, player1: 0, player2: 0 },
        tpsEMA: { single: 0, player1: 0, player2: 0 },
        tapTimestamps: { single: [], player1: [], player2: [] },
        tpsUpdateInterval: null,
        maxTPS: { single: 0, player1: 0, player2: 0 },
        tapQueues: [],
        inputLockUntil: 0,
        ultraSpeedTimeout: null,
        ultraSpeedTimeout1: null,
        ultraSpeedTimeout2: null,
      };

      const SPEED_STEP = 0.5; // æ¯ 0.5 TPS ä¸€ç´šï¼Œç¸½å…± 10 ç´šï¼ˆè¶Šé«˜è¶Šç‚«ï¼‰
      const tpsToLevel = tps => Math.max(1, Math.min(10, Math.floor(tps / SPEED_STEP) + 1));

      // æ­£ç¢ºçš„ TPS è¨ˆç®—å‡½æ•¸ - åŸºæ–¼æ»‘å‹•çª—å£
      function calculateRealTPS(playerId) {
        const now = performance.now();
        const timestamps = GameState.tapTimestamps[playerId];

        // æ¸…é™¤è¶…é1ç§’çš„èˆŠè¨˜éŒ„
        while (timestamps.length > 0 && now - timestamps[0] > 1000) {
          timestamps.shift();
        }

        return timestamps.length;
      }

      // æ›´æ–°æ‰€æœ‰ç©å®¶çš„ TPS é¡¯ç¤º
      function updateAllTPS() {
        if (!GameState.settings.showTps || !GameState.isPlaying) return;

        const players = GameState.mode === 'single' ? ['single'] : ['player1', 'player2'];

        players.forEach(playerId => {
          const realTPS = calculateRealTPS(playerId);
          GameState.tpsEMA[playerId] = realTPS; // ç›´æ¥ä½¿ç”¨çœŸå¯¦ TPSï¼Œä¸éœ€è¦ EMA å¹³æ»‘

          // è¨˜éŒ„æœ€é«˜ TPS å³°å€¼
          if (realTPS > GameState.maxTPS[playerId]) {
            GameState.maxTPS[playerId] = realTPS;
          }
        });

        uiManager.updateTpsHUD();
      }
      let fxWorker = null,
        fxCanvas = null,
        offscreen = null,
        dpr = 1;
      const isLowPower =
        ('connection' in navigator && navigator.connection && navigator.connection.saveData) ||
        false;

      // ===== FX Worker åˆå§‹åŒ– =====
      function setupWorker() {
        // é˜²æ­¢é‡è¤‡åˆå§‹åŒ–
        if (offscreen || fxWorker) {
          console.log('Worker already initialized, skipping...');
          return;
        }

        fxCanvas = document.getElementById('fxCanvas');
        if (!fxCanvas) {
          console.error('Canvas initialization failed');
          return;
        }

        dpr = Math.min(isLowPower ? 1.25 : 1.6, window.devicePixelRatio || 1);

        try {
          if ('OffscreenCanvas' in window && fxCanvas.transferControlToOffscreen) {
            offscreen = fxCanvas.transferControlToOffscreen();
            fxWorker = new Worker('./fx.worker.js', { type: 'module' });
            fxWorker.postMessage({ type: 'init', canvas: offscreen, dpr, lowPower: isLowPower }, [
              offscreen,
            ]);
          } else {
            fxWorker = new Worker('./fx.worker.js', { type: 'module' });
            fxWorker.postMessage({ type: 'init-fallback' }, []);
          }
          resizeFx();
          sendSettingsToWorker();
        } catch (error) {
          console.error('Worker setup failed: [ERROR FILTERED]');
          // å›é€€åˆ°é OffscreenCanvas æ¨¡å¼
          if (!fxWorker) {
            fxWorker = new Worker('./fx.worker.js', { type: 'module' });
            fxWorker.postMessage({ type: 'init-fallback' }, []);
            resizeFx();
            sendSettingsToWorker();
          }
        }
      }
      function resizeFx() {
        const r = fxCanvas.getBoundingClientRect();
        if (offscreen) {
          fxWorker.postMessage({
            type: 'resize',
            width: r.width,
            height: r.height,
            dpr,
          });
        } else {
          fxCanvas.width = Math.floor(r.width * dpr);
          fxCanvas.height = Math.floor(r.height * dpr);
          fxWorker.postMessage({
            type: 'resize',
            width: r.width,
            height: r.height,
            dpr,
          });
        }
      }
      window.addEventListener('resize', resizeFx);
      function sendSettingsToWorker() {
        fxWorker &&
          fxWorker.postMessage({
            type: 'config',
            rippleEnabled: GameState.settings.rippleEnabled,
            lightningEnabled: GameState.settings.lightningEnabled,
          });
      }

      // ===== éŸ³æ•ˆç®¡ç† =====
      class AdvancedAudioManager {
        constructor() {
          this.audioContext = null;
          this.masterGain = null;
          this.sounds = {};
          this.isInitialized = false;
        }
        async init() {
          if (this.isInitialized) return;
          try {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
              latencyHint: 'interactive',
              sampleRate: 44100,
            });
            this.masterGain = this.audioContext.createGain();
            this.masterGain.connect(this.audioContext.destination);
            if (this.audioContext.state === 'suspended') await this.audioContext.resume();
            const sr = this.audioContext.sampleRate;
            this.sounds.tap = this.renderTap(sr);
            this.sounds.countdown = this.renderBeep(sr);
            this.sounds.victory = this.renderVictory(sr);
            this.sounds.firework = this.renderFirework(sr);
            this.isInitialized = true;
          } catch (e) {}
        }
        renderTap(sr) {
          const n = Math.floor(sr * 0.06),
            b = this.audioContext.createBuffer(1, n, sr),
            d = b.getChannelData(0);
          for (let i = 0; i < n; i++) {
            const t = i / sr;
            d[i] = Math.sin(2 * Math.PI * (900 - 400 * t) * t) * Math.exp(-t * 28) * 0.35;
          }
          return b;
        }
        renderBeep(sr) {
          const n = Math.floor(sr * 0.18),
            b = this.audioContext.createBuffer(1, n, sr),
            d = b.getChannelData(0);
          for (let i = 0; i < n; i++) {
            const t = i / sr;
            d[i] = Math.sin(2 * Math.PI * 1000 * t) * Math.exp(-t * 12) * 0.4;
          }
          return b;
        }
        renderVictory(sr) {
          const n = Math.floor(sr * 0.9),
            b = this.audioContext.createBuffer(2, n, sr);
          const m = [261.63, 329.63, 392, 523.25, 659.25, 784];
          for (let c = 0; c < 2; c++) {
            const d = b.getChannelData(c);
            for (let i = 0; i < n; i++) {
              const t = i / sr,
                idx = Math.floor(t * 6) % m.length;
              d[i] = Math.sin(2 * Math.PI * m[idx] * t) * Math.max(0, 1 - t) * 0.24;
            }
          }
          return b;
        }
        renderFirework(sr) {
          const n = Math.floor(sr * 0.35),
            b = this.audioContext.createBuffer(2, n, sr);
          for (let c = 0; c < 2; c++) {
            const d = b.getChannelData(c);
            for (let i = 0; i < n; i++) {
              const t = i / sr;
              d[i] = (Math.random() - 0.5) * 2 * Math.exp(-t * 10) * 0.3;
            }
          }
          return b;
        }
        play(name, vol = 1) {
          if (!this.isInitialized || !GameState.settings.soundEnabled) return;
          const buf = this.sounds[name];
          if (!buf) return;
          try {
            const src = this.audioContext.createBufferSource();
            const g = this.audioContext.createGain();
            g.gain.value = vol;
            src.buffer = buf;
            src.connect(g);
            g.connect(this.masterGain);
            src.start();
          } catch (e) {}
        }
        vibrate(ms = 40) {
          if (!GameState.settings.vibrationEnabled) return;
          if ('vibrate' in navigator) {
            try {
              navigator.vibrate(ms);
            } catch (e) {}
          }
        }
      }

      // ===== å„²å­˜ç®¡ç† =====
      class StorageManager {
        constructor() {
          this.KEY = 'eliteTapBattle_FineLightning_PWA_v3';
          this.loadSettings();
        }
        loadSettings() {
          try {
            const d = JSON.parse(localStorage.getItem(this.KEY) || '{}');
            if (d.settings) Object.assign(GameState.settings, d.settings);
          } catch (_) {}
        }
        saveSettings() {
          const d = this.loadData();
          d.settings = { ...GameState.settings };
          this.saveData(d);
        }
        saveScore(mode, score, score2 = null, maxTPS = null) {
          const d = this.loadData();
          const rec = {
            mode,
            score,
            score2,
            maxTPS,
            duration: GameState.settings.gameDuration,
            date: new Date().toISOString(),
            ts: Date.now(),
          };
          d.leaderboard = d.leaderboard || [];
          d.leaderboard.push(rec);
          d.leaderboard.sort((a, b) => b.score - a.score);
          d.leaderboard = d.leaderboard.slice(0, 100); // å¢åŠ åˆ°100æ¢è¨˜éŒ„
          this.saveData(d);
        }
        getLeaderboard(mode = null, duration = null, limit = 10) {
          const d = this.loadData();
          let r = d.leaderboard || [];
          if (mode) r = r.filter(x => x.mode === mode);
          if (duration && duration !== 'all') r = r.filter(x => x.duration === parseInt(duration));
          return r.slice(0, limit);
        }
        clearData() {
          if (confirm('ç¢ºå®šè¦æ¸…é™¤æ‰€æœ‰éŠæˆ²è¨˜éŒ„å—ï¼Ÿ')) {
            localStorage.removeItem(this.KEY);
            alert('è¨˜éŒ„å·²æ¸…é™¤ï¼');
          }
        }
        loadData() {
          try {
            return JSON.parse(localStorage.getItem(this.KEY) || '{}');
          } catch (_) {
            return {};
          }
        }
        saveData(d) {
          try {
            localStorage.setItem(this.KEY, JSON.stringify(d));
          } catch (_) {
            alert('å„²å­˜ç©ºé–“å·²æ»¿ï¼Œè«‹æ¸…é™¤èˆŠè¨˜éŒ„ï¼');
          }
        }
      }

      // ===== UI ç®¡ç† =====
      class AdvancedUIManager {
        constructor() {
          this.encouragementTimeout = null;
          document.getElementById('startSingleBtn').addEventListener('click', async () => {
            await this.initAudio();
            gameEngine.startSinglePlayer();
          });
          document.getElementById('startDualBtn').addEventListener('click', async () => {
            await this.initAudio();
            gameEngine.startDualPlayer();
          });
          document.getElementById('leaderboardBtn').addEventListener('click', () => {
            this.currentLeaderboardMode = 'single';
            this.currentLeaderboardPage = 1;
            this.currentLeaderboardDuration = 'all';
            this.updateLeaderboard('single', 1, 'all');
            this.showModal('leaderboardModal');
            this.updateLeaderboardTabs();
            this.updateTimeTabsUI();
          });
          document.getElementById('settingsBtn').addEventListener('click', () => {
            this.showSettings();
          });
          document.getElementById('gameInfoBtn').addEventListener('click', () => {
            this.showModal('gameInfoModal');
          });

          document
            .getElementById('gameExit')
            .addEventListener('click', () => gameEngine.exitGame());
          document.getElementById('playAgainBtn').addEventListener('click', () => {
            this.hideModal('resultModal');
            if (GameState.mode === 'single') gameEngine.startSinglePlayer();
            else gameEngine.startDualPlayer();
          });
          document.getElementById('backToMenuBtn').addEventListener('click', () => {
            this.hideModal('resultModal');
            gameEngine.exitGame();
          });

          // é›™äººæ¨¡å¼æŒ‰éˆ•äº‹ä»¶ç›£è½å™¨
          document.getElementById('playAgainDualBtn').addEventListener('click', () => {
            this.hideModal('resultModal');
            gameEngine.startDualPlayer();
          });
          document.getElementById('backToMenuDualBtn').addEventListener('click', () => {
            this.hideModal('resultModal');
            gameEngine.exitGame();
          });

          document
            .getElementById('closeLeaderboardBtn')
            .addEventListener('click', () => this.hideModal('leaderboardModal'));
          document.getElementById('clearLeaderboardBtn').addEventListener('click', () => {
            if (confirm('ç¢ºå®šè¦æ¸…é™¤æ‰€æœ‰è¨˜éŒ„å—ï¼Ÿæ­¤æ“ä½œç„¡æ³•å¾©åŸã€‚')) {
              storageManager.clearData();
              this.updateLeaderboard(
                this.currentLeaderboardMode || 'single',
                1,
                this.currentLeaderboardDuration || 'all'
              );
            }
          });

          // æ’è¡Œæ¦œåˆ†é å’Œæ¨™ç±¤äº‹ä»¶
          this.setupLeaderboardEvents();

          document.getElementById('closeSettingsBtn').addEventListener('click', () => {
            this.saveSettings();
            this.hideModal('settingsModal');
            sendSettingsToWorker();
          });
          document.getElementById('closeGameInfoBtn').addEventListener('click', () => {
            this.hideModal('gameInfoModal');
          });

          document.addEventListener('keydown', e => {
            if (e.code === 'Escape' && GameState.isPlaying) gameEngine.exitGame();
          });

          this.loadSettingsUI();
          this.setupPWAInstallBanner();
        }
        async initAudio() {
          if (!audioManager.isInitialized) await audioManager.init();
        }
        showGameScreen(mode) {
          document.getElementById('menuScreen').classList.add('hidden');
          const gs = document.getElementById('gameScreen');
          gs.classList.add('active');
          gs.setAttribute('aria-hidden', 'false');
          if (mode === 'single') {
            document.getElementById('singlePlayerArea').style.display = 'flex';
            document.getElementById('dualPlayerArea').style.display = 'none';
            // é‡ç½®é¼“å‹µæ–‡å­—
            const encouragementEl = document.getElementById('encouragementText');
            if (encouragementEl) {
              encouragementEl.textContent = 'é»æ“Šé–‹å§‹ä½ çš„æŒ‘æˆ°ï¼';
            }
          } else {
            document.getElementById('singlePlayerArea').style.display = 'none';
            document.getElementById('dualPlayerArea').style.display = 'grid';
          }
        }
        showMenuScreen() {
          document.getElementById('menuScreen').classList.remove('hidden');
          const gs = document.getElementById('gameScreen');
          gs.classList.remove('active');
          gs.setAttribute('aria-hidden', 'true');
        }
        updateGameUI() {
          document.getElementById('gameMode').textContent =
            GameState.mode === 'single' ? 'å–®äººæŒ‘æˆ°' : 'é›™äººå°æˆ°';
          document.getElementById('hudModeP1').textContent = 'é›™äººå°æˆ°';
          document.getElementById('hudModeP2').textContent = 'é›™äººå°æˆ°';
          this.applyTpsToggle();
        }
        updateScoreDisplay() {
          if (GameState.mode === 'single') {
            document.getElementById('singleScore').textContent = GameState.scores.single;
          } else {
            document.getElementById('player1Score').textContent = GameState.scores.player1;
            document.getElementById('player2Score').textContent = GameState.scores.player2;
          }
        }
        animateScore(playerId) {
          const el = document.getElementById(`${playerId}Score`);
          if (!el) return;
          el.style.animation = 'none';
          el.offsetHeight;
          el.style.animation = 'pulse .28s ease-in-out alternate';
        }
        updateTimer() {
          const t = Math.ceil(GameState.timeLeft);
          const tEl = document.getElementById('gameTimer');
          tEl.textContent = t;
          if (GameState.timeLeft <= 5 && GameState.timeLeft > 0) {
            tEl.style.color = 'var(--sky-600)';
            tEl.style.animation = 'pulse .5s ease-in-out infinite alternate';
          } else {
            tEl.style.color = 'var(--primary)';
            tEl.style.animation = '';
          }
          document.getElementById('hudTimerP1').textContent = t;
          document.getElementById('hudTimerP2').textContent = t;
          this.updateTpsHUD();
        }

        updateEncouragementText(currentTPS) {
          const textEl = document.getElementById('encouragementText');
          if (!textEl) return;

          const message = getEncouragementMessage(currentTPS);

          // åªæœ‰åœ¨æ–‡å­—æ”¹è®Šæ™‚æ‰æ›´æ–°ï¼Œä¸¦é¡¯ç¤ºè‡³å°‘1ç§’
          if (textEl.textContent !== message) {
            textEl.textContent = message;

            // æ·»åŠ é–ƒçˆæ•ˆæœ
            textEl.style.animation = 'none';
            textEl.offsetHeight; // å¼·åˆ¶é‡ç¹ª
            textEl.style.animation = 'pulse 0.5s ease-in-out';

            // ç¢ºä¿é¡¯ç¤ºè‡³å°‘1ç§’
            clearTimeout(this.encouragementTimeout);
            this.encouragementTimeout = setTimeout(() => {
              // 1ç§’å¾Œå¯ä»¥æ›´æ–°ç‚ºæ–°çš„æ–‡å­—
            }, 1000);
          }
        }
        updateTpsHUD() {
          if (!GameState.settings.showTps) return;
          const p1Wrapper = document.getElementById('hudTpsP1Wrapper'),
            p2Wrapper = document.getElementById('hudTpsP2Wrapper'),
            headerTps = document.getElementById('headerTps');

          if (GameState.mode === 'single') {
            const tps = GameState.tpsEMA.single;
            const tpsDisplay = Math.min(99999, Math.round(tps * 10) / 10);
            const valueEl = headerTps.querySelector('.hud-tps-value');
            valueEl.textContent = tpsDisplay;

            // æ·»åŠ é«˜ TPS æ¼¸å±¤æ–‡å­—æ•ˆæœ
            if (tps > 30) {
              valueEl.classList.add('high-tps');
            } else {
              valueEl.classList.remove('high-tps');
            }

            // 30TPSä»¥ä¸Šè§¸ç™¼RGBå‹•ç•«æ•ˆæœï¼Œä¸¦è‡³å°‘æŒçºŒé¡¯ç¤º1ç§’
            if (tps > 30) {
              headerTps.classList.add('ultra-speed');
              // è¨­ç½®æœ€çŸ­é¡¯ç¤ºæ™‚é–“1ç§’
              if (GameState.ultraSpeedTimeout) {
                clearTimeout(GameState.ultraSpeedTimeout);
              }
              GameState.ultraSpeedTimeout = setTimeout(() => {
                if (GameState.tpsEMA.single <= 30) {
                  headerTps.classList.remove('ultra-speed');
                }
              }, 1000);
            } else if (!GameState.ultraSpeedTimeout) {
              headerTps.classList.remove('ultra-speed');
            }
          } else {
            const tps1 = GameState.tpsEMA.player1;
            const tps2 = GameState.tpsEMA.player2;
            const tps1Display = Math.min(99999, Math.round(tps1 * 10) / 10);
            const tps2Display = Math.min(99999, Math.round(tps2 * 10) / 10);

            const p1 = document.getElementById('hudTpsP1');
            const p2 = document.getElementById('hudTpsP2');
            const value1El = p1.querySelector('.hud-tps-value');
            const value2El = p2.querySelector('.hud-tps-value');

            value1El.textContent = tps1Display;
            value2El.textContent = tps2Display;

            // Player 1 - 30TPSä»¥ä¸Šè§¸ç™¼RGBå‹•ç•«æ•ˆæœï¼Œä¸¦è‡³å°‘æŒçºŒé¡¯ç¤º1ç§’
            if (tps1 > 30) {
              p1Wrapper.classList.add('ultra-speed');
              if (GameState.ultraSpeedTimeout1) {
                clearTimeout(GameState.ultraSpeedTimeout1);
              }
              GameState.ultraSpeedTimeout1 = setTimeout(() => {
                if (GameState.tpsEMA.player1 <= 30) {
                  p1Wrapper.classList.remove('ultra-speed');
                }
              }, 1000);
            } else if (!GameState.ultraSpeedTimeout1) {
              p1Wrapper.classList.remove('ultra-speed');
            }

            // Player 2 - 30TPSä»¥ä¸Šè§¸ç™¼RGBå‹•ç•«æ•ˆæœï¼Œä¸¦è‡³å°‘æŒçºŒé¡¯ç¤º1ç§’
            if (tps2 > 30) {
              p2Wrapper.classList.add('ultra-speed');
              if (GameState.ultraSpeedTimeout2) {
                clearTimeout(GameState.ultraSpeedTimeout2);
              }
              GameState.ultraSpeedTimeout2 = setTimeout(() => {
                if (GameState.tpsEMA.player2 <= 30) {
                  p2Wrapper.classList.remove('ultra-speed');
                }
              }, 1000);
            } else if (!GameState.ultraSpeedTimeout2) {
              p2Wrapper.classList.remove('ultra-speed');
            }
          }
        }
        applyTpsToggle() {
          const el1 = document.getElementById('hudTpsP1Wrapper'),
            el2 = document.getElementById('hudTpsP2Wrapper'),
            headerTps = document.getElementById('headerTps');
          if (GameState.settings.showTps) {
            if (el1) el1.classList.add('show');
            if (el2) el2.classList.add('show');
            if (headerTps) headerTps.style.display = 'flex';
          } else {
            if (el1) el1.classList.remove('show');
            if (el2) el2.classList.remove('show');
            if (headerTps) headerTps.style.display = 'none';
          }
        }
        showResult(r) {
          const modal = document.getElementById('resultModal');
          const singleResult = document.getElementById('singleResult');
          const dualResult = document.getElementById('dualResult');

          if (GameState.mode === 'single') {
            // é¡¯ç¤ºå–®äººæ¨¡å¼çµæœ
            singleResult.style.display = 'block';
            dualResult.style.display = 'none';

            const title = document.getElementById('resultTitle');
            const score = document.getElementById('resultScore');
            const tpsDiv = document.getElementById('resultTPS');
            const badge = document.getElementById('achievementBadge');

            title.textContent = 'å–®äººæŒ‘æˆ°å®Œæˆï¼';
            score.textContent = r.score;
            tpsDiv.textContent = (Math.round(GameState.maxTPS.single * 10) / 10).toFixed(1);

            // æ ¹æ“šæˆç¸¾è¨­ç½®æˆå°±å¾½ç« 
            if (GameState.maxTPS.single >= 50) {
              badge.innerHTML =
                '<div class="badge-icon"><span class="material-symbols-rounded">rocket_launch</span></div><div class="badge-text">è¶…éŸ³é€Ÿå¤§å¸«</div>';
            } else if (GameState.maxTPS.single >= 30) {
              badge.innerHTML =
                '<div class="badge-icon"><span class="material-symbols-rounded">bolt</span></div><div class="badge-text">é–ƒé›»å¿«æ‰‹</div>';
            } else if (GameState.maxTPS.single >= 20) {
              badge.innerHTML =
                '<div class="badge-icon"><span class="material-symbols-rounded">local_fire_department</span></div><div class="badge-text">é»æ“Šé«˜æ‰‹</div>';
            } else {
              badge.innerHTML =
                '<div class="badge-icon"><span class="material-symbols-rounded">star</span></div><div class="badge-text">åˆéœ²é‹’èŠ’</div>';
            }
          } else {
            // é¡¯ç¤ºé›™äººæ¨¡å¼çµæœ
            singleResult.style.display = 'none';
            dualResult.style.display = 'block';

            const dualTitle = document.getElementById('dualResultTitle');
            const dualSubtitle = document.getElementById('dualResultSubtitle');
            const winnerCrown = document.getElementById('winnerCrown');

            const player1Result = document.getElementById('player1Result');
            const player2Result = document.getElementById('player2Result');
            const player1Medal = document.getElementById('player1Medal');
            const player2Medal = document.getElementById('player2Medal');

            const player1ScoreEl = document.getElementById('player1ResultScore');
            const player2ScoreEl = document.getElementById('player2ResultScore');
            const player1TPSEl = document.getElementById('player1ResultTPS');
            const player2TPSEl = document.getElementById('player2ResultTPS');

            const dualBadge = document.getElementById('dualAchievementBadge');

            // è¨­ç½®åˆ†æ•¸å’ŒTPS
            player1ScoreEl.textContent = r.score;
            player2ScoreEl.textContent = r.score2;
            player1TPSEl.textContent = (Math.round(GameState.maxTPS.player1 * 10) / 10).toFixed(1);
            player2TPSEl.textContent = (Math.round(GameState.maxTPS.player2 * 10) / 10).toFixed(1);

            // é‡ç½®æ¨£å¼
            player1Result.classList.remove('winner');
            player2Result.classList.remove('winner');

            // è¨­ç½®ç²å‹è€…
            if (r.winner) {
              dualTitle.textContent = `${r.winner === 'player1' ? 'ç©å®¶ 1' : 'ç©å®¶ 2'} ç²å‹ï¼`;
              dualSubtitle.textContent = 'æ­å–œç²å¾—å‹åˆ©ï¼';
              winnerCrown.style.display = 'block';

              if (r.winner === 'player1') {
                player1Result.classList.add('winner');
                player1Medal.innerHTML =
                  '<div class="medal-icon"><span class="material-symbols-rounded" style="font-size: 48px; color: #ffd700;">military_tech</span></div>';
                player2Medal.innerHTML =
                  '<div class="medal-icon"><span class="material-symbols-rounded" style="font-size: 48px; color: #c0c0c0;">military_tech</span></div>';
              } else {
                player2Result.classList.add('winner');
                player1Medal.innerHTML =
                  '<div class="medal-icon"><span class="material-symbols-rounded" style="font-size: 48px; color: #c0c0c0;">military_tech</span></div>';
                player2Medal.innerHTML =
                  '<div class="medal-icon"><span class="material-symbols-rounded" style="font-size: 48px; color: #ffd700;">military_tech</span></div>';
              }
            } else {
              dualTitle.textContent = 'å¹³æ‰‹å°æ±ºï¼';
              dualSubtitle.textContent = 'å‹¢å‡åŠ›æ•µçš„è¼ƒé‡ï¼';
              winnerCrown.style.display = 'none';
              player1Medal.innerHTML =
                '<div class="medal-icon"><span class="material-symbols-rounded" style="font-size: 48px; color: var(--accent);">handshake</span></div>';
              player2Medal.innerHTML =
                '<div class="medal-icon"><span class="material-symbols-rounded" style="font-size: 48px; color: var(--accent);">handshake</span></div>';
            }

            // è¨­ç½®æˆå°±å¾½ç« 
            const maxTPS = Math.max(GameState.maxTPS.player1, GameState.maxTPS.player2);
            if (maxTPS >= 50) {
              dualBadge.innerHTML =
                '<div class="badge-icon"><span class="material-symbols-rounded">crown</span></div><div class="badge-text">å°æˆ°ç‹è€…</div>';
            } else if (maxTPS >= 30) {
              dualBadge.innerHTML =
                '<div class="badge-icon"><span class="material-symbols-rounded">swords</span></div><div class="badge-text">æ¿€æˆ°é«˜æ‰‹</div>';
            } else if (maxTPS >= 20) {
              dualBadge.innerHTML =
                '<div class="badge-icon"><span class="material-symbols-rounded">local_fire_department</span></div><div class="badge-text">é»æ“Šé”äºº</div>';
            } else {
              dualBadge.innerHTML =
                '<div class="badge-icon"><span class="material-symbols-rounded">handshake</span></div><div class="badge-text">å‹èª¼ç¬¬ä¸€</div>';
            }
          }

          modal.classList.add('show');
          modal.setAttribute('aria-hidden', 'false');
        }
        showModal(id) {
          const m = document.getElementById(id);
          m.classList.add('show');
          m.setAttribute('aria-hidden', 'false');
        }
        hideModal(id) {
          const m = document.getElementById(id);
          m.classList.remove('show');
          m.setAttribute('aria-hidden', 'true');
        }
        showSettings() {
          document.getElementById('soundEnabled').checked = GameState.settings.soundEnabled;
          document.getElementById('vibrationEnabled').checked = GameState.settings.vibrationEnabled;
          document.getElementById('gameDuration').value = GameState.settings.gameDuration;
          document.getElementById('rippleEnabled').checked = GameState.settings.rippleEnabled;
          document.getElementById('lightningEnabled').checked = GameState.settings.lightningEnabled;
          document.getElementById('showTps').checked = GameState.settings.showTps;
          this.showModal('settingsModal');
        }
        saveSettings() {
          GameState.settings.soundEnabled = document.getElementById('soundEnabled').checked;
          GameState.settings.vibrationEnabled = document.getElementById('vibrationEnabled').checked;
          GameState.settings.gameDuration = parseInt(
            document.getElementById('gameDuration').value,
            10
          );
          GameState.settings.rippleEnabled = document.getElementById('rippleEnabled').checked;
          GameState.settings.lightningEnabled = document.getElementById('lightningEnabled').checked;
          GameState.settings.showTps = document.getElementById('showTps').checked;
          storageManager.saveSettings();
          this.applyTpsToggle();
          sendSettingsToWorker();
        }
        loadSettingsUI() {
          document.getElementById('soundEnabled').checked = GameState.settings.soundEnabled;
          document.getElementById('vibrationEnabled').checked = GameState.settings.vibrationEnabled;
          document.getElementById('gameDuration').value = GameState.settings.gameDuration;
          document.getElementById('rippleEnabled').checked = GameState.settings.rippleEnabled;
          document.getElementById('lightningEnabled').checked = GameState.settings.lightningEnabled;
          document.getElementById('showTps').checked = GameState.settings.showTps;
          this.applyTpsToggle();
        }
        updateLeaderboard(mode = 'single', page = 1, duration = 'all') {
          const itemsPerPage = 8;
          const list = document.getElementById('leaderboardList');
          const currentPageEl = document.getElementById('currentPage');
          const totalPagesEl = document.getElementById('totalPages');
          const prevBtn = document.getElementById('prevPageBtn');
          const nextBtn = document.getElementById('nextPageBtn');

          // ç²å–æŒ‡å®šæ¨¡å¼å’Œæ™‚é–“çš„è¨˜éŒ„
          const allRecords = storageManager.getLeaderboard(mode, duration, 100);
          const totalPages = Math.max(1, Math.ceil(allRecords.length / itemsPerPage));
          const startIndex = (page - 1) * itemsPerPage;
          const records = allRecords.slice(startIndex, startIndex + itemsPerPage);

          // æ›´æ–°åˆ†é ä¿¡æ¯
          currentPageEl.textContent = page;
          totalPagesEl.textContent = totalPages;
          prevBtn.disabled = page <= 1;
          nextBtn.disabled = page >= totalPages;

          // æ¸²æŸ“è¨˜éŒ„åˆ—è¡¨
          if (records.length === 0) {
            list.innerHTML = `
              <div class="empty-leaderboard">
                <div class="empty-icon">
                  <span class="material-symbols-rounded" style="font-size: 48px; opacity: 0.5;">trophy</span>
                </div>
                <div class="empty-text">æš«ç„¡è¨˜éŒ„</div>
                <div class="empty-hint">é–‹å§‹éŠæˆ²ä¾†å‰µé€ ä½ çš„ç¬¬ä¸€å€‹è¨˜éŒ„å§ï¼</div>
              </div>
            `;
            return;
          }

          list.innerHTML = records
            .map((record, index) => {
              const globalRank = startIndex + index + 1;
              const date = new Date(record.date).toLocaleDateString('zh-TW', {
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
              });

              let rankClass = 'rank-other';
              if (globalRank === 1) rankClass = 'rank-1';
              else if (globalRank === 2) rankClass = 'rank-2';
              else if (globalRank === 3) rankClass = 'rank-3';

              const scoreText =
                record.score2 != null ? `${record.score} : ${record.score2}` : record.score;

              const tpsText = record.maxTPS ? `æœ€é«˜ TPS: ${record.maxTPS}` : '';

              return `
              <div class="leaderboard-item">
                <div class="rank-badge ${rankClass}">${globalRank}</div>
                <div class="player-info">
                  <div class="player-name">${
                    record.mode === 'single' ? 'å–®äººæŒ‘æˆ°' : 'é›™äººå°æˆ°'
                  }${record.duration ? ` (${record.duration}ç§’)` : ''}</div>
                  <div class="player-date">${date}</div>
                </div>
                <div class="score-info">
                  <div class="score-value">${scoreText}</div>
                  ${tpsText ? `<div class="tps-info">${tpsText}</div>` : ''}
                </div>
              </div>
            `;
            })
            .join('');

          // å­˜å„²ç•¶å‰ç‹€æ…‹
          this.currentLeaderboardMode = mode;
          this.currentLeaderboardPage = page;
          this.currentLeaderboardDuration = duration;
        }

        setupLeaderboardEvents() {
          // æ¨¡å¼æ¨™ç±¤åˆ‡æ›
          document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
              const mode = btn.dataset.mode;
              this.currentLeaderboardMode = mode;
              this.currentLeaderboardPage = 1;
              this.updateLeaderboard(mode, 1, this.currentLeaderboardDuration || 'all');
              this.updateLeaderboardTabs();
            });
          });

          // æ™‚é–“æ¨™ç±¤åˆ‡æ›
          document.querySelectorAll('.time-tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
              const duration = btn.dataset.time;
              this.currentLeaderboardDuration = duration;
              this.currentLeaderboardPage = 1;
              this.updateLeaderboard(this.currentLeaderboardMode || 'single', 1, duration);
              this.updateTimeTabsUI();
            });
          });

          // åˆ†é æŒ‰éˆ•
          document.getElementById('prevPageBtn').addEventListener('click', () => {
            if (this.currentLeaderboardPage > 1) {
              this.currentLeaderboardPage--;
              this.updateLeaderboard(
                this.currentLeaderboardMode,
                this.currentLeaderboardPage,
                this.currentLeaderboardDuration
              );
            }
          });

          document.getElementById('nextPageBtn').addEventListener('click', () => {
            this.currentLeaderboardPage++;
            this.updateLeaderboard(
              this.currentLeaderboardMode,
              this.currentLeaderboardPage,
              this.currentLeaderboardDuration
            );
          });
        }

        updateLeaderboardTabs() {
          document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.mode === this.currentLeaderboardMode);
          });
        }

        updateTimeTabsUI() {
          document.querySelectorAll('.time-tab-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.time === this.currentLeaderboardDuration);
          });
        }

        // PWA å®‰è£æç¤º
        setupPWAInstallBanner() {
          const banner = document.getElementById('installBanner');
          const title = document.getElementById('installTitle');
          const hint = document.getElementById('installHint');
          const btnInstall = document.getElementById('installAction');
          const btnDismiss = document.getElementById('installDismiss');
          const DISMISS_KEY = 'etb_install_dismiss_v1';
          if (localStorage.getItem(DISMISS_KEY) === '1') return;
          const isStandalone =
            window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone;
          if (isStandalone) return;
          const isiOS = /iphone|ipad|ipod/i.test(navigator.userAgent);
          let deferredPrompt = null;
          if (!isiOS) {
            window.addEventListener('beforeinstallprompt', e => {
              e.preventDefault();
              deferredPrompt = e;
              title.textContent = 'å®‰è£ Click Fun';
              hint.textContent = 'æ”¯æ´é›¢ç·šã€å•Ÿå‹•æ›´å¿«ã€å…¨è¢å¹•é«”é©—';
              btnInstall.textContent = 'å®‰è£';
              banner.classList.add('show');
              document.documentElement.classList.add('has-install-banner');
            });
            btnInstall.onclick = async () => {
              if (!deferredPrompt) return;
              deferredPrompt.prompt();
              const { outcome } = await deferredPrompt.userChoice;
              if (outcome !== 'dismissed') banner.classList.remove('show');
              deferredPrompt = null;
            };
          } else {
            title.textContent = 'åŠ å…¥ä¸»ç•«é¢ï¼ˆiOSï¼‰';
            hint.innerHTML = 'åœ¨ Safari æŒ‰ <b>åˆ†äº«</b> â†’ <b>åŠ å…¥åˆ°ä¸»ç•«é¢</b>ï¼Œå³å¯é›¢ç·šå…¨è¢å¹•éŠç©';
            btnInstall.textContent = 'çŸ¥é“äº†';
            banner.classList.add('show');
            document.documentElement.classList.add('has-install-banner');
            btnInstall.onclick = () => {
              banner.classList.remove('show');
              document.documentElement.classList.remove('has-install-banner');
            };
          }
          btnDismiss.onclick = () => {
            localStorage.setItem(DISMISS_KEY, '1');
            banner.classList.remove('show');
            document.documentElement.classList.remove('has-install-banner');
          };
        }
      }

      // ===== è¼¸å…¥ç®¡ç†ï¼ˆæ‰¹æ¬¡ä¸Ÿåˆ° Workerï¼‰=====
      class AdvancedInputManager {
        constructor(gameEngine) {
          this.gameEngine = gameEngine;
          const area = document.getElementById('gameArea');
          area.addEventListener('pointerdown', this.onDown.bind(this), {
            passive: false,
          });
          area.addEventListener('pointermove', this.onMove.bind(this), {
            passive: false,
          });
          area.addEventListener('pointerup', this.onUp.bind(this), {
            passive: false,
          });
          area.addEventListener('pointercancel', this.onUp.bind(this), {
            passive: false,
          });
          area.addEventListener('contextmenu', e => e.preventDefault());
          area.addEventListener('dblclick', e => e.preventDefault());

          const pump = () => {
            if (fxWorker && GameState.tapQueues.length) {
              fxWorker.postMessage({
                type: 'batch',
                taps: GameState.tapQueues.splice(0, GameState.tapQueues.length),
              });
            }
            requestAnimationFrame(pump);
          };
          requestAnimationFrame(pump);
        }
        onDown(e) {
          if (!GameState.isPlaying) return;
          if (performance.now() < GameState.inputLockUntil) return;
          e.preventDefault();
          const rect = e.currentTarget.getBoundingClientRect();
          const x = e.clientX - rect.left,
            y = e.clientY - rect.top;
          const id = e.pointerId;
          e.currentTarget.setPointerCapture(id);

          let playerId;
          if (GameState.mode === 'single') {
            playerId = 'single';
          } else {
            playerId = y < rect.height / 2 ? 'player1' : 'player2';
          }

          GameState.pointers.set(id, { playerId, element: e.currentTarget });

          const now = performance.now();

          // è¨˜éŒ„é»æ“Šæ™‚é–“æˆ³ç”¨æ–¼ TPS è¨ˆç®—
          GameState.tapTimestamps[playerId].push(now);

          // è¨ˆç®—ç•¶å‰çœŸå¯¦ TPS
          const currentTPS = calculateRealTPS(playerId);
          GameState.tpsEMA[playerId] = currentTPS;

          const tier = tpsToLevel(currentTPS);
          GameState.lastTapTime[playerId] = now;

          // å–®äººæ¨¡å¼ç¬¬ä¸€æ¬¡é»æ“Šæ™‚é–‹å§‹è¨ˆæ™‚
          if (GameState.mode === 'single' && !GameState.hasStarted) {
            GameState.hasStarted = true;
            this.gameEngine.startTime = now; // é‡è¨­é–‹å§‹æ™‚é–“
            console.log('ğŸ® éŠæˆ²è¨ˆæ™‚é–‹å§‹ï¼');
          }

          GameState.activePointers.set(id, { x, y, playerId, tier });
          GameState.scores[playerId]++;
          uiManager.updateScoreDisplay();
          uiManager.animateScore(playerId);

          // å–®äººæ¨¡å¼æ›´æ–°é¼“å‹µæ–‡å­—
          if (GameState.mode === 'single') {
            uiManager.updateEncouragementText(currentTPS);
          }

          // æ°´æ³¢ç´‹è§¸ç™¼æ¢ä»¶ï¼šæ¯ç§’é»æ“Š > 20 ä¸”æ¯ 3 æ¬¡è§¸ç™¼ä¸€æ¬¡
          const rippleOk = currentTPS > 20 && GameState.scores[playerId] % 3 === 0;
          // è¶…é«˜é€Ÿé–ƒé›»æ•ˆæœï¼šTPS > 30 (èˆ‡é¡¯ç¤ºé‚è¼¯ä¿æŒä¸€è‡´)
          const ultraSpeed = currentTPS > 30;

          GameState.tapQueues.push({
            x,
            y,
            ts: now,
            tier,
            playerId,
            mode: GameState.mode,
            rippleEligible: rippleOk,
            ultraSpeed: ultraSpeed,
          });

          audioManager.play('tap', 0.5);
          audioManager.vibrate();
          if (GameState.mode === 'dual') {
            const zone = document.querySelector(`.player-zone.${playerId}`);
            if (zone) zone.classList.add('active');
          }
        }
        onMove(e) {
          if (!GameState.isPlaying) return;
          e.preventDefault();
          const rect = e.currentTarget.getBoundingClientRect();
          const x = e.clientX - rect.left,
            y = e.clientY - rect.top;
          const p = GameState.activePointers.get(e.pointerId);
          if (p) {
            p.x = x;
            p.y = y;
          }
        }
        onUp(e) {
          const meta = GameState.pointers.get(e.pointerId);
          if (meta) {
            try {
              meta.element.releasePointerCapture(e.pointerId);
            } catch (_) {}
            if (GameState.mode === 'dual') {
              const zone = document.querySelector(`.player-zone.${meta.playerId}`);
              if (zone) zone.classList.remove('active');
            }
          }
          GameState.pointers.delete(e.pointerId);
          GameState.activePointers.delete(e.pointerId);
        }
      }

      // ===== éŠæˆ²å¼•æ“ =====
      class AdvancedGameEngine {
        constructor() {
          this.animationFrame = null;
          this.startTime = 0;
          this.lastCountdownSecond = null;
          this.isFullscreen = false;
        }
        async startSinglePlayer() {
          await this.enterFullscreen();
          this.startGame('single', 0);
        }
        async startDualPlayer() {
          await this.enterFullscreen();
          this.startGame('dual', 1000);
        } // é–‹é ­å»¶é² 1 ç§’

        async enterFullscreen() {
          // åªåœ¨ç§»å‹•è¨­å‚™æ™‚è‡ªå‹•å…¨è¢å¹•
          if (!this.isMobileDevice()) {
            return;
          }

          try {
            const el = document.documentElement;
            if (el.requestFullscreen) await el.requestFullscreen();
            else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
            this.isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement);
          } catch (_) {}
        }

        isMobileDevice() {
          // æª¢æ¸¬æ˜¯å¦ç‚ºç§»å‹•è¨­å‚™ï¼ˆæ‰‹æ©Ÿæˆ–å¹³æ¿ï¼‰
          const userAgent = navigator.userAgent.toLowerCase();
          const isMobile = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(
            userAgent
          );
          const isTablet = /ipad|android(?!.*mobile)/i.test(userAgent);
          const hasTouchScreen = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
          const isSmallScreen = window.innerWidth <= 1024; // å¹³æ¿å°ºå¯¸ä»¥ä¸‹

          return isMobile || isTablet || (hasTouchScreen && isSmallScreen);
        }
        async exitFullscreen() {
          const doc = document;
          const fsEl = doc.fullscreenElement || doc.webkitFullscreenElement;
          if (!fsEl) {
            this.isFullscreen = false;
            return;
          }
          if (doc.visibilityState !== 'visible') {
            this.isFullscreen = false;
            return;
          }
          try {
            if (doc.exitFullscreen) {
              await doc.exitFullscreen().catch(() => {});
            } else if (doc.webkitExitFullscreen) {
              doc.webkitExitFullscreen();
            }
          } catch (_) {}
          this.isFullscreen = false;
        }

        startGame(mode, delayMs) {
          if (GameState.isPlaying) return;
          GameState.mode = mode;
          GameState.isPlaying = true;
          GameState.hasStarted = false; // é‡ç½®é–‹å§‹ç‹€æ…‹
          GameState.timeLeft = GameState.settings.gameDuration;
          GameState.scores = { single: 0, player1: 0, player2: 0 };
          GameState.pointers.clear();
          GameState.activePointers.clear();
          GameState.lastTapTime = { single: 0, player1: 0, player2: 0 };
          GameState.tpsEMA = { single: 0, player1: 0, player2: 0 };
          GameState.tapTimestamps = { single: [], player1: [], player2: [] };
          GameState.maxTPS = { single: 0, player1: 0, player2: 0 };
          GameState.tapQueues.length = 0;

          // å•Ÿå‹• TPS æ›´æ–°å®šæ™‚å™¨
          if (GameState.tpsUpdateInterval) {
            clearInterval(GameState.tpsUpdateInterval);
          }
          GameState.tpsUpdateInterval = setInterval(updateAllTPS, 100); // æ¯100msæ›´æ–°ä¸€æ¬¡
          GameState.inputLockUntil = performance.now() + (mode === 'dual' ? delayMs : 0);

          const appEl = document.getElementById('app');
          appEl.classList.toggle('single', mode === 'single');
          appEl.classList.toggle('dual', mode === 'dual');

          document.getElementById('gameHeader').classList.toggle('hidden', mode === 'dual');
          uiManager.showGameScreen(mode);
          uiManager.updateGameUI();
          uiManager.updateScoreDisplay();
          resizeFx();

          const syncActive = () => {
            if (!GameState.isPlaying) return;
            const arr = [];
            GameState.activePointers.forEach(v => arr.push(v));
            fxWorker && fxWorker.postMessage({ type: 'active', active: arr });
            setTimeout(syncActive, 66);
          };
          syncActive();

          this.startTime = performance.now() + delayMs;
          this.lastCountdownSecond = null;

          const loop = ts => {
            if (!GameState.isPlaying) return;

            // åœ¨é›™äººæ¨¡å¼ä¸­ï¼Œæ–¼é å®šé–‹å§‹æ™‚é–“è‡ªå‹•å•Ÿå‹•è¨ˆæ™‚ï¼ˆé¿å…æ°¸ä¸å€’æ•¸ï¼‰
            if (GameState.mode === 'dual' && !GameState.hasStarted && ts >= this.startTime) {
              GameState.hasStarted = true;
            }

            // åªæœ‰åœ¨éŠæˆ²å·²é–‹å§‹æ™‚æ‰è¨ˆæ™‚
            if (GameState.hasStarted) {
              const elapsed = (ts - this.startTime) / 1000;
              GameState.timeLeft = Math.max(
                0,
                GameState.settings.gameDuration - Math.max(0, elapsed)
              );
            }
            uiManager.updateTimer();

            if (GameState.timeLeft <= 3 && GameState.timeLeft > 0) {
              const secs = Math.ceil(GameState.timeLeft);
              if (secs !== this.lastCountdownSecond) {
                audioManager.play('countdown');
                this.lastCountdownSecond = secs;
              }
            }
            if (GameState.timeLeft <= 0) {
              this.endGame();
              return;
            }
            this.animationFrame = requestAnimationFrame(loop);
          };
          this.animationFrame = requestAnimationFrame(loop);
        }

        async endGame() {
          GameState.isPlaying = false;
          if (this.animationFrame) {
            cancelAnimationFrame(this.animationFrame);
            this.animationFrame = null;
          }
          // æ¸…ç† TPS æ›´æ–°å®šæ™‚å™¨
          if (GameState.tpsUpdateInterval) {
            clearInterval(GameState.tpsUpdateInterval);
            GameState.tpsUpdateInterval = null;
          }
          // æ¸…ç† Ultra Speed timeout
          if (GameState.ultraSpeedTimeout) {
            clearTimeout(GameState.ultraSpeedTimeout);
            GameState.ultraSpeedTimeout = null;
          }
          if (GameState.ultraSpeedTimeout1) {
            clearTimeout(GameState.ultraSpeedTimeout1);
            GameState.ultraSpeedTimeout1 = null;
          }
          if (GameState.ultraSpeedTimeout2) {
            clearTimeout(GameState.ultraSpeedTimeout2);
            GameState.ultraSpeedTimeout2 = null;
          }
          const result = this.calculateResult();
          await this.playFireworks(); // æ’­å®Œç…™ç«å†é¡¯ç¤ºçµæœ
          audioManager.play('victory', 0.9);
          uiManager.showResult(result);
        }

        calculateResult() {
          const r = { hasWinner: false, winner: null, score: 0, score2: 0 };
          if (GameState.mode === 'single') {
            r.score = GameState.scores.single;
            r.hasWinner = r.score > 0;
            storageManager.saveScore('single', r.score, null, GameState.maxTPS.single);
          } else {
            r.score = GameState.scores.player1;
            r.score2 = GameState.scores.player2;
            if (r.score > r.score2) {
              r.winner = 'player1';
              r.hasWinner = true;
            } else if (r.score2 > r.score) {
              r.winner = 'player2';
              r.hasWinner = true;
            }
            const maxTPS = Math.max(GameState.maxTPS.player1, GameState.maxTPS.player2);
            storageManager.saveScore(
              'dual',
              Math.max(r.score, r.score2),
              Math.min(r.score, r.score2),
              maxTPS
            );
          }
          return r;
        }

        playFireworks() {
          const container = document.getElementById('fireworkContainer');
          const colors = [
            '#f66fb9',
            '#ffb2dc',
            '#7ccaff',
            '#52b7ff',
            '#ffffff',
            '#ff6b6b',
            '#4ecdc4',
            '#45b7d1',
            '#96ceb4',
            '#ffeaa7',
            '#dda0dd',
            '#ff69b4',
            '#00ff00',
            '#ffd700',
            '#ff4500',
          ];
          const count = 24;
          const duration = 5500;

          return new Promise(resolve => {
            // Add victory screen flash effect
            document.getElementById('app').style.animation = 'victoryFlash 0.8s ease-out';

            for (let i = 0; i < count; i++) {
              setTimeout(
                () => {
                  const cx = Math.random() * window.innerWidth;
                  const cy = Math.random() * (window.innerHeight * 0.7) + window.innerHeight * 0.15;
                  const fireworkType = Math.random();

                  if (fireworkType < 0.3) {
                    // Large burst firework
                    this.createBurstFirework(container, cx, cy, colors, 18, 180);
                  } else if (fireworkType < 0.6) {
                    // Ring firework
                    this.createRingFirework(container, cx, cy, colors, 16, 150);
                  } else if (fireworkType < 0.85) {
                    // Spiral firework
                    this.createSpiralFirework(container, cx, cy, colors, 24, 200);
                  } else {
                    // Chain explosion
                    this.createChainFirework(container, cx, cy, colors, 12, 120);
                  }

                  // Enhanced audio with random pitch
                  audioManager.play('firework', 0.3 + Math.random() * 0.4);

                  // Random victory sound bursts
                  if (Math.random() < 0.3) {
                    setTimeout(() => audioManager.play('victory', 0.1), Math.random() * 300);
                  }
                },
                i * (duration / count) + Math.random() * 200
              );
            }

            // Grand finale
            setTimeout(() => {
              this.createGrandFinale(container, colors);
              audioManager.play('victory', 0.8);
            }, duration * 0.8);

            setTimeout(() => {
              container.innerHTML = '';
              document.getElementById('app').style.animation = '';
              resolve();
            }, duration + 800);
          });
        }

        createBurstFirework(container, cx, cy, colors, particles, maxDist) {
          for (let j = 0; j < particles; j++) {
            const dot = document.createElement('div');
            dot.className = 'firework';
            const c = colors[Math.floor(Math.random() * colors.length)];
            dot.style.background = `radial-gradient(circle, ${c}, transparent)`;
            dot.style.boxShadow = `0 0 20px ${c}, 0 0 40px ${c}`;
            dot.style.left = cx + 'px';
            dot.style.top = cy + 'px';
            dot.style.width = 4 + Math.random() * 6 + 'px';
            dot.style.height = dot.style.width;
            container.appendChild(dot);

            const ang = (j / particles) * Math.PI * 2 + Math.random() * 0.5;
            const dist = maxDist * (0.7 + Math.random() * 0.6);
            const dur = 1200 + Math.random() * 800;

            dot
              .animate(
                [
                  { transform: 'translate(0,0) scale(1)', opacity: 1 },
                  {
                    transform: `translate(${Math.cos(ang) * dist}px, ${
                      Math.sin(ang) * dist + Math.random() * 50
                    }px) scale(0)`,
                    opacity: 0,
                  },
                ],
                {
                  duration: dur,
                  easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',
                }
              )
              .addEventListener('finish', () => dot.remove());
          }
        }

        createRingFirework(container, cx, cy, colors, particles, radius) {
          for (let j = 0; j < particles; j++) {
            const dot = document.createElement('div');
            dot.className = 'firework';
            const c = colors[Math.floor(Math.random() * colors.length)];
            dot.style.background = c;
            dot.style.boxShadow = `0 0 15px ${c}`;
            dot.style.left = cx + 'px';
            dot.style.top = cy + 'px';
            dot.style.width = '6px';
            dot.style.height = '6px';
            container.appendChild(dot);

            const ang = (j / particles) * Math.PI * 2;
            const dur = 1000 + Math.random() * 400;

            dot
              .animate(
                [
                  { transform: 'translate(0,0) scale(1)', opacity: 1 },
                  {
                    transform: `translate(${Math.cos(ang) * radius}px, ${
                      Math.sin(ang) * radius
                    }px) scale(0.3)`,
                    opacity: 0.8,
                    offset: 0.7,
                  },
                  {
                    transform: `translate(${Math.cos(ang) * radius * 1.2}px, ${
                      Math.sin(ang) * radius * 1.2
                    }px) scale(0)`,
                    opacity: 0,
                  },
                ],
                { duration: dur, easing: 'ease-out' }
              )
              .addEventListener('finish', () => dot.remove());
          }
        }

        createSpiralFirework(container, cx, cy, colors, particles, maxDist) {
          for (let j = 0; j < particles; j++) {
            const dot = document.createElement('div');
            dot.className = 'firework';
            const c = colors[Math.floor(Math.random() * colors.length)];
            dot.style.background = `linear-gradient(45deg, ${c}, transparent)`;
            dot.style.boxShadow = `0 0 12px ${c}`;
            dot.style.left = cx + 'px';
            dot.style.top = cy + 'px';
            dot.style.width = '3px';
            dot.style.height = '15px';
            dot.style.borderRadius = '50%';
            container.appendChild(dot);

            const spiral = j * 0.8;
            const dist = (j / particles) * maxDist;
            const dur = 1500 + Math.random() * 600;

            dot
              .animate(
                [
                  {
                    transform: 'translate(0,0) rotate(0deg) scale(1)',
                    opacity: 1,
                  },
                  {
                    transform: `translate(${Math.cos(spiral) * dist}px, ${
                      Math.sin(spiral) * dist
                    }px) rotate(${(spiral * 180) / Math.PI}deg) scale(0)`,
                    opacity: 0,
                  },
                ],
                { duration: dur, easing: 'ease-out' }
              )
              .addEventListener('finish', () => dot.remove());
          }
        }

        createChainFirework(container, cx, cy, colors, particles, dist) {
          for (let j = 0; j < particles; j++) {
            setTimeout(() => {
              const dot = document.createElement('div');
              dot.className = 'firework';
              const c = colors[Math.floor(Math.random() * colors.length)];
              dot.style.background = c;
              dot.style.boxShadow = `0 0 25px ${c}, 0 0 50px ${c}`;
              dot.style.left = cx + (Math.random() - 0.5) * 100 + 'px';
              dot.style.top = cy + (Math.random() - 0.5) * 100 + 'px';
              dot.style.width = '8px';
              dot.style.height = '8px';
              container.appendChild(dot);

              const ang = Math.random() * Math.PI * 2;
              const d = dist * (0.8 + Math.random() * 0.4);

              dot
                .animate(
                  [
                    { transform: 'translate(0,0) scale(1)', opacity: 1 },
                    {
                      transform: `translate(${Math.cos(ang) * d}px, ${
                        Math.sin(ang) * d
                      }px) scale(0)`,
                      opacity: 0,
                    },
                  ],
                  { duration: 800, easing: 'ease-out' }
                )
                .addEventListener('finish', () => dot.remove());
            }, j * 50);
          }
        }

        createGrandFinale(container, colors) {
          // Create multiple large bursts simultaneously
          for (let i = 0; i < 6; i++) {
            const cx = (window.innerWidth / 6) * (i + 0.5);
            const cy = window.innerHeight * (0.3 + Math.random() * 0.4);
            this.createBurstFirework(container, cx, cy, colors, 32, 250);

            setTimeout(() => {
              this.createRingFirework(container, cx, cy, colors, 24, 200);
            }, 300);
          }

          // Add confetti shower
          setTimeout(() => {
            for (let i = 0; i < 100; i++) {
              const confetti = document.createElement('div');
              confetti.style.position = 'absolute';
              confetti.style.width = '6px';
              confetti.style.height = '6px';
              confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
              confetti.style.left = Math.random() * window.innerWidth + 'px';
              confetti.style.top = '-10px';
              confetti.style.borderRadius = '2px';
              container.appendChild(confetti);

              confetti
                .animate(
                  [
                    { transform: 'translateY(0) rotate(0deg)', opacity: 1 },
                    {
                      transform: `translateY(${
                        window.innerHeight + 50
                      }px) rotate(${Math.random() * 720}deg)`,
                      opacity: 0,
                    },
                  ],
                  {
                    duration: 3000 + Math.random() * 2000,
                    easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',
                  }
                )
                .addEventListener('finish', () => confetti.remove());
            }
          }, 600);
        }

        async exitGame() {
          GameState.isPlaying = false;
          if (this.animationFrame) {
            cancelAnimationFrame(this.animationFrame);
            this.animationFrame = null;
          }
          // æ¸…ç† TPS æ›´æ–°å®šæ™‚å™¨
          if (GameState.tpsUpdateInterval) {
            clearInterval(GameState.tpsUpdateInterval);
            GameState.tpsUpdateInterval = null;
          }
          // æ¸…ç† Ultra Speed timeout
          if (GameState.ultraSpeedTimeout) {
            clearTimeout(GameState.ultraSpeedTimeout);
            GameState.ultraSpeedTimeout = null;
          }
          if (GameState.ultraSpeedTimeout1) {
            clearTimeout(GameState.ultraSpeedTimeout1);
            GameState.ultraSpeedTimeout1 = null;
          }
          if (GameState.ultraSpeedTimeout2) {
            clearTimeout(GameState.ultraSpeedTimeout2);
            GameState.ultraSpeedTimeout2 = null;
          }
          await this.exitFullscreen();
          uiManager.showMenuScreen();
        }
      }

      // ===== åˆå§‹åŒ– =====
      let audioManager, inputManager, gameEngine, storageManager, uiManager;

      // æš´éœ²åˆ°å…¨å±€ä½œç”¨åŸŸä»¥ä¾¿èª¿è©¦
      window.GameState = GameState;
      let isInitialized = false;

      document.addEventListener('DOMContentLoaded', () => {
        // é˜²æ­¢é‡è¤‡åˆå§‹åŒ–
        if (isInitialized) {
          console.log('Game already initialized, skipping...');
          return;
        }

        console.log('Initializing Click Fun...');

        try {
          // æª¢æŸ¥ç‰ˆæœ¬æ›´æ–°
          checkForUpdates();

          audioManager = new AdvancedAudioManager();
          storageManager = new StorageManager();
          gameEngine = new AdvancedGameEngine();
          uiManager = new AdvancedUIManager();
          inputManager = new AdvancedInputManager(gameEngine);
          setupWorker();

          // æ›´æ–°ç‰ˆæœ¬è™Ÿé¡¯ç¤º
          updateVersionDisplay();

          // æš´éœ²åˆ°å…¨å±€ä½œç”¨åŸŸä»¥ä¾¿èª¿è©¦
          window.gameEngine = gameEngine;
          window.uiManager = uiManager;
          window.inputManager = inputManager;

          isInitialized = true;
          console.log('âœ… Game initialization complete');
        } catch (error) {
          console.error('âŒ Game initialization failed: [ERROR FILTERED]');
        }

        if ('serviceWorker' in navigator) {
          navigator.serviceWorker.register('./sw.js').catch(() => {
            /* éœé»˜å¤±æ•— */
          });
        }

        if (
          'connection' in navigator &&
          navigator.connection &&
          navigator.connection.saveData === true
        ) {
          document.documentElement.classList.add('save-data');
        }

        // å­—é«”è¼‰å…¥æª¢æ¸¬å„ªåŒ–ï¼Œé¿å…é¦–å±çœ‹åˆ°è‹±æ–‡
        Promise.all([
          document.fonts.load('1em "Material Symbols Rounded"'),
          document.fonts.load('1em "Fredoka One"'),
        ])
          .then(() => {
            document.documentElement.classList.add('fonts-ready');
          })
          .catch(() => {
            // å¦‚æœè¼‰å…¥å¤±æ•—ï¼Œ1.5ç§’å¾Œé¡¯ç¤ºé¿å…æ°¸ä¹…éš±è—
            setTimeout(() => document.documentElement.classList.add('fonts-ready'), 1500);
          });
      });

      // å…¨è¢å¹•äº‹ä»¶ï¼šä¸è¦åœ¨é€™è£¡å‘¼å« exitGame() ä»¥å…éè¿´
      document.addEventListener('fullscreenchange', () => {
        const isFs = !!(document.fullscreenElement || document.webkitFullscreenElement);
        gameEngine.isFullscreen = isFs;
        if (!isFs && GameState.isPlaying) {
          GameState.isPlaying = false;
          uiManager.showMenuScreen();
        }
      });

      // ç¦ç”¨é›™æ“Šæ”¾å¤§
      (function preventZoom() {
        let last = 0;
        document.addEventListener(
          'touchend',
          e => {
            const now = Date.now();
            if (now - last <= 300) {
              e.preventDefault();
            }
            last = now;
          },
          { passive: false }
        );
        ['gesturestart', 'gesturechange', 'gestureend'].forEach(evt =>
          document.addEventListener(evt, e => e.preventDefault())
        );
      })();